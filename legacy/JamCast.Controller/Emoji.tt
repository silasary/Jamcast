<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\packages\Newtonsoft.Json.10.0.3\lib\net45\Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ template hostspecific="true" language="C#" debug="true" #>
<#
    //Options & Settings

    //Whether to generate the static properties referencing each Emoji
    bool GenerateStaticProperties = true;

    //Name filter for emojis - set this to only only generate classes
    //for emoji that contain key words (clean name format, all underscores)
    //Example: string[] NameFilter = {"FACE"};
    string[] NameFilter = {};

    //Category filter for emojis - set this to only only generate
    //emojis in the given categories. See EmojiCategory enum below for examples
    //Example: string[] CategoryFilter = {"People"};
    string[] CategoryFilter = {};

#>
/*
    EmojiSharp v0.2
    Created by John Mazouri - http://jmazouri.com/
    emoji.json from the awesome emoji-data project - https://github.com/iamcal/emoji-data

    This file should have been autogenerated from a T4 template - feel free to delete the
    template if you're never going to need to update the emoji list later on.
*/

using System;   
using System.Collections.Generic;

namespace EmojiSharp
{
    public enum EmojiCategory
    {
        Symbols,
        Nature,
        Foods,
        People,
        Places,
        Activity,
        Celebration,
        Other
    }

    public partial class Emoji
    {
        public string Name { get; set; }
        public string Unified { get; set; }
        public string[] Variations { get; set; }
        public string Docomo { get; set; }
        public string Au { get; set; }
        public string Softbank { get; set; }
        public string Google { get; set; }
        public string Image { get; set; }
        public int SheetX { get; set; }
        public int SheetY { get; set; }
        public string ShortName { get { return ShortNames != null && ShortNames.Length > 0 ? ShortNames[0] : null; }}
        public string[] ShortNames { get; set; }
        public string Text { get { return Texts != null && Texts.Length > 0 ? Texts[0] : null; }}
        public string[] Texts { get; set; }
        public EmojiCategory Category { get; set; }
        public int SortOrder { get; set; }
        public bool AppleHasImage { get; set; }
        public bool GoogleHasImage { get; set; }
        public bool TwitterHasImage { get; set; }
        public bool EmojioneHasImage { get; set; }

        public override string ToString()
        {
            return ShortName;
        }

        public string AsShortcode()
        {
            return String.Format(":{0}:", ShortName);
        }

        public static Dictionary<string, Emoji> All = new Dictionary<string, Emoji>()
        {
    <#
        var emojis = JArray.Parse(File.ReadAllText(Host.ResolvePath("emoji.json")));

        foreach (var entry in emojis)
        {
		if (entry == null) { continue; }
		if (entry["name"] == null) { continue; }
		if (entry["name"].Value<string>() == null) { continue; }
            string cleanedName = entry["name"].Value<string>().Replace(' ', '_').Replace('-', '_').Trim();
            if (String.IsNullOrWhiteSpace(cleanedName)) continue;

            if (NameFilter.Length > 0 && !NameFilter.Any(d=>cleanedName.Contains(d))) continue;

            string cleanedCategory = entry["category"].Value<string>() ?? "Other";

            if (CategoryFilter.Length > 0 && !CategoryFilter.Contains(cleanedCategory)) continue;
            
    #>
        {"<#=entry["short_names"].First().Value<string>()#>", 
            new Emoji 
            {
                Name = <#=QuotedValue(entry["name"])#>,
                SortOrder = <#=(entry["sort_order"].Value<string>() ?? "0")#>,

                Unified = <#=QuotedValue(entry["unified"])#>,
                Variations = <#=TokenToCsharpArray(entry["variations"])#>,

                Docomo = <#=QuotedValue(entry["docomo"])#>,
                Au = <#=QuotedValue(entry["au"])#>,
                Softbank = <#=QuotedValue(entry["softbank"])#>,
                Google = <#=QuotedValue(entry["google"])#>,

                AppleHasImage = <#=entry["has_img_apple"].Value<string>().ToLower()#>,
                GoogleHasImage = <#=entry["has_img_google"].Value<string>().ToLower()#>,
                TwitterHasImage = <#=entry["has_img_twitter"].Value<string>().ToLower()#>,
                EmojioneHasImage = <#=entry["has_img_emojione"].Value<string>().ToLower()#>,

                Image = <#=QuotedValue(entry["image"])#>,
                SheetX = <#=(entry["sheet_x"].Value<string>()?? "0")#>,
                SheetY = <#=(entry["sheet_y"].Value<string>()?? "0")#>,

                ShortNames = <#=TokenToCsharpArray(entry["short_names"])#>,
                Texts = <#=TokenToCsharpArray(entry["texts"])#>
            }},

    <#
        }
    #>
    };

    <# 
        
    #>
    }
}

<#+
    public string TokenToCsharpArray(JToken token, bool includeCtor = true)
    {
		if (token == null)
		{
			return "new string[0]";
		}
        string result = 
            token.HasValues
            ? token.Select(d => '"' + d.Value<string>().Replace("\\", "\\\\") + '"').Aggregate((cur, next) => cur + ", " + next)
            : string.Empty;

        if (includeCtor)
        {
            return "new string[] { " + result + " }";
        }

        return result;
    }

    public string QuotedValue(object input)
    {
		if (input == null) return "\"\"";
        if (String.IsNullOrEmpty(input.ToString())) return "null";
		input = input.ToString().Replace("\\", "\\\\");
        return String.Format("\"{0}\"", input);
    }
#>